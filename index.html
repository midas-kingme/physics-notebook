<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Lab • Library</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400&display=swap"
        rel="stylesheet">

    <!-- CSS -->
    <link rel="stylesheet" href="css/common.css">
    <link rel="stylesheet" href="css/home.css">

    <!-- Theme Init (Blocking to prevent flash) -->
    <script>
        const savedTheme = localStorage.getItem('physics-notebook-theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        document.body && document.body.setAttribute('data-theme', savedTheme); // Fallback
    </script>

    <!-- Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
</head>

<body>

    <nav>
        <div class="logo">
            <i data-lucide="atom"></i>
            Physics • Notebook
        </div>
        <div class="nav-controls">
            <a href="https://github.com/CasberryIndia/Physics-Notebook" target="_blank" class="github-btn"
                title="View Source on GitHub">
                <i data-lucide="github" style="width:16px;"></i>
                <span id="starCount">...</span>
            </a>
            <button id="themeBtn">
                <i data-lucide="moon" style="width:16px;"></i> Theme
            </button>
        </div>
    </nav>

    <div class="library-header">
        <h1 class="hero-title">Interactive Library</h1>

        <div class="controls-bar">
            <!-- Search -->
            <div class="search-container">
                <i data-lucide="search" class="search-icon"></i>
                <input type="text" id="searchInput" placeholder="Search topics (e.g., 'Gravity', 'Waves')...">
            </div>

            <!-- Filters -->
            <div class="filter-group" id="filterContainer">
                <button class="filter-chip active" data-filter="all">All Domains</button>
                <button class="filter-chip" data-filter="Mechanics">Mechanics</button>
                <button class="filter-chip" data-filter="Waves">Waves & Optics</button>
                <button class="filter-chip" data-filter="Electromagnetism">Electromagnetism</button>
                <button class="filter-chip" data-filter="Quantum">Quantum</button>
            </div>
        </div>
    </div>

    <!-- Main Grid -->
    <main class="grid-container" id="cardsGrid">
        <!-- Cards Injected via JS -->
    </main>

    <footer class="main-footer">
        <p>Want to add a concept? <a href="contribute.html">Contribute</a></p>
    </footer>

    <!-- Scripts -->
    <script src="js/common.js"></script>
    <script>
        // ------------------------------------------------------------------
        // DATA
        // ------------------------------------------------------------------
        const DATA = [
            {
                id: 'oscillation',
                title: 'Harmonic Oscillation',
                domain: 'Mechanics',
                desc: 'Restoring forces, damping, and resonance in spring-mass systems.',
                type: 'oscillation',
                href: 'Concepts/simple-oscillations.html'
            },
            {
                id: 'projectile',
                title: 'Projectile Motion',
                domain: 'Mechanics',
                desc: 'Kinematics of objects in flight under the influence of gravity and drag.',
                type: 'projectile',
                href: 'Concepts/projectile-motion.html'
            },
            {
                id: 'waves',
                title: 'Wave Interference',
                domain: 'Waves',
                desc: 'Superposition principle, constructive and destructive interference.',
                type: 'waves',
                href: 'Concepts/wave-interference.html'
            },
            {
                id: 'orbit',
                title: 'Orbital Mechanics',
                domain: 'Mechanics',
                desc: 'Kepler’s laws and gravitational attraction between celestial bodies.',
                type: 'orbit',
                href: 'Concepts/orbital-mechanics.html'
            },
            {
                id: 'fields',
                title: 'Electric Fields',
                domain: 'Electromagnetism',
                desc: 'Visualizing vector fields generated by point charges.',
                type: 'fields',
                href: 'Concepts/electric-fields.html'
            },
            {
                id: 'magnetic',
                title: 'Magnetic Fields',
                domain: 'Electromagnetism',
                desc: 'Magnetic dipoles, current-carrying wires, and electromagnetic induction.',
                type: 'magnetic',
                href: 'Concepts/magnetic-fields.html'
            },
            {
                id: 'double-slit',
                title: 'Double Slit Experiment',
                domain: 'Quantum',
                desc: 'The probabilistic nature of photons and wave-particle duality.',
                type: 'slit',
                href: 'Concepts/double-slit-experiment.html'
            },
            {
                id: 'pendulum',
                title: 'Simple Pendulum',
                domain: 'Mechanics',
                desc: 'Periodicity and small-angle approximation in suspended masses.',
                type: 'pendulum',
                href: 'Concepts/simple-pendulum.html'
            }
        ];

        // ------------------------------------------------------------------
        // VISUALIZATION CLASSES (Mini-Sims)
        // ------------------------------------------------------------------

        class BaseVisual {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.isVisible = false;

                // Initialize Colors
                this.updateColors();

                // Random start time so they're not all synced perfectly
                this.time = Math.random() * 100;

                // Initial resize
                this.resize();
            }

            updateColors() {
                this.color = getComputedStyle(document.body).getPropertyValue('--text-main').trim();
                this.accent = getComputedStyle(document.body).getPropertyValue('--accent').trim();
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.width = this.canvas.width;
                this.height = this.canvas.height;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.width, this.height);
            }

            // Should be overridden
            draw() { }
        }

        class OscillationVisual extends BaseVisual {
            draw() {
                if (!this.isVisible) return;
                this.time += 0.05;
                this.clear();
                const x = Math.sin(this.time) * (this.width * 0.3);
                const cx = this.width / 2;
                const cy = this.height / 2;

                this.ctx.strokeStyle = this.color;
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                this.ctx.moveTo(cx - (this.width * 0.35), cy);
                for (let i = 0; i < 20; i++) {
                    let px = (cx - (this.width * 0.35)) + ((x + (this.width * 0.35)) / 20) * i;
                    let py = cy + (i % 2 == 0 ? -5 : 5);
                    this.ctx.lineTo(px, py);
                }
                this.ctx.lineTo(cx + x, cy);
                this.ctx.stroke();

                this.ctx.fillStyle = this.accent;
                this.ctx.beginPath();
                this.ctx.arc(cx + x, cy, 8, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        class ProjectileVisual extends BaseVisual {
            constructor(c) { super(c); this.t = 0; }
            draw() {
                if (!this.isVisible) return;
                this.t += 0.02;
                if (this.t > 2) this.t = 0;
                this.clear();

                const startX = 20;
                const startY = this.height - 20;
                const simX = this.t * (this.width * 0.8);
                const normT = this.t / 2;
                const simY = (normT * 4 - Math.pow(normT * 2, 2)) * (this.height * 0.8);

                this.ctx.fillStyle = this.accent;
                this.ctx.beginPath();
                this.ctx.arc(startX + simX, startY - simY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = this.color;
                this.ctx.globalAlpha = 0.2;
                this.ctx.beginPath();
                for (let i = 0; i < this.t; i += 0.05) {
                    let sx = i * (this.width * 0.8);
                    let nT = i / 2;
                    let sy = (nT * 4 - Math.pow(nT * 2, 2)) * (this.height * 0.8);
                    this.ctx.lineTo(startX + sx, startY - sy);
                }
                this.ctx.stroke();
                this.ctx.globalAlpha = 1;
            }
        }

        class WavesVisual extends BaseVisual {
            draw() {
                if (!this.isVisible) return;
                this.time += 0.05;
                this.clear();
                this.ctx.beginPath();
                this.ctx.strokeStyle = this.accent;
                this.ctx.lineWidth = 2;

                for (let x = 0; x < this.width; x += 5) {
                    const y = Math.sin(x * 0.05 + this.time) * 20 + Math.sin(x * 0.03 - this.time) * 10;
                    if (x === 0) this.ctx.moveTo(x, this.height / 2 + y);
                    else this.ctx.lineTo(x, this.height / 2 + y);
                }
                this.ctx.stroke();
            }
        }

        class OrbitVisual extends BaseVisual {
            draw() {
                if (!this.isVisible) return;
                this.time += 0.03;
                this.clear();
                const cx = this.width / 2;
                const cy = this.height / 2;

                this.ctx.fillStyle = this.color;
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, 15, 0, Math.PI * 2);
                this.ctx.fill();

                const rx = this.width * 0.3;
                const ry = this.height * 0.2;
                const x = cx + Math.cos(this.time) * rx;
                const y = cy + Math.sin(this.time) * ry;

                this.ctx.strokeStyle = this.color;
                this.ctx.globalAlpha = 0.1;
                this.ctx.beginPath();
                this.ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.globalAlpha = 1;

                this.ctx.fillStyle = this.accent;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 6, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        class FieldVisual extends BaseVisual {
            draw() {
                if (!this.isVisible) return;
                this.time += 0.02;
                this.clear();
                const cx = this.width / 2;
                const cy = this.height / 2;

                this.ctx.fillStyle = this.color;
                for (let x = 20; x < this.width; x += 40) {
                    for (let y = 20; y < this.height; y += 40) {
                        const dx = x - cx;
                        const dy = y - cy;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const offset = (this.time * 20) % 20;
                        const angle = Math.atan2(dy, dx);
                        const px = x + Math.cos(angle) * offset;
                        const py = y + Math.sin(angle) * offset;
                        const size = Math.max(0, 3 - (dist / 150));
                        this.ctx.beginPath();
                        this.ctx.arc(px, py, size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
        }

        class PendulumVisual extends BaseVisual {
            draw() {
                if (!this.isVisible) return;
                this.time += 0.05;
                this.clear();
                const cx = this.width / 2;
                const angle = Math.sin(this.time) * 0.5;
                const len = this.height * 0.6;
                const endX = cx + Math.sin(angle) * len;
                const endY = 20 + Math.cos(angle) * len;

                this.ctx.strokeStyle = this.color;
                this.ctx.beginPath();
                this.ctx.moveTo(cx, 20);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();

                this.ctx.fillStyle = this.accent;
                this.ctx.beginPath();
                this.ctx.arc(endX, endY, 10, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        class SlitVisual extends BaseVisual {
            draw() {
                if (!this.isVisible) return;
                this.time += 0.1;
                this.clear();
                const bands = 20;
                const w = this.width / bands;
                for (let i = 0; i < bands; i++) {
                    const center = bands / 2;
                    const dist = Math.abs(i - center);
                    const intensity = Math.max(0, 1 - (dist * 0.2)) + (Math.sin(this.time + i) * 0.1);
                    this.ctx.fillStyle = this.accent;
                    this.ctx.globalAlpha = intensity * 0.8;
                    this.ctx.fillRect(i * w, 0, w, this.height);
                }
                this.ctx.globalAlpha = 1;
            }
        }

        class MagneticVisual extends BaseVisual {
            draw() {
                if (!this.isVisible) return;
                this.time += 0.05;
                this.clear();
                const cx = this.width / 2;
                const cy = this.height / 2;

                // Draw magnet
                const magnetWidth = 60;
                const magnetHeight = 20;

                // North pole (red)
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.fillRect(cx - magnetWidth/2, cy - magnetHeight/2, magnetWidth/2, magnetHeight);

                // South pole (blue)
                this.ctx.fillStyle = '#3498db';
                this.ctx.fillRect(cx, cy - magnetHeight/2, magnetWidth/2, magnetHeight);

                // Draw field lines
                this.ctx.strokeStyle = this.accent;
                this.ctx.lineWidth = 1.5;
                this.ctx.globalAlpha = 0.6;

                const numLines = 4;
                for (let i = 0; i < numLines; i++) {
                    const angle = (i / numLines) * Math.PI - Math.PI/2 + 0.2;
                    const rStart = magnetWidth/2 + 5;

                    // Trace field line
                    this.ctx.beginPath();
                    let x = cx - magnetWidth/2;
                    let y = cy + rStart * Math.sin(angle);
                    this.ctx.moveTo(x, y);

                    for (let t = 0; t < Math.PI; t += 0.05) {
                        const r = rStart * Math.exp(t * 0.3);
                        x = cx + r * Math.cos(t + Math.PI);
                        y = cy + r * Math.sin(t + Math.PI);
                        this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();
                }

                this.ctx.globalAlpha = 1;

                // Animate particles along field lines
                for (let i = 0; i < 3; i++) {
                    const t = (this.time + i * 2) % (Math.PI * 2);
                    const r = 40 + Math.sin(t) * 20;
                    const x = cx + r * Math.cos(t + Math.PI);
                    const y = cy + r * Math.sin(t + Math.PI);

                    this.ctx.fillStyle = this.accent;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }

        // ------------------------------------------------------------------
        // APP LOGIC
        // ------------------------------------------------------------------

        const App = {
            visuals: [],
            observer: null,

            init() {
                this.setupObserver();
                this.setupFilters();
                this.renderGrid(DATA);
                this.animateLoop();

                // Color updates
                window.addEventListener('theme-changed', () => {
                    this.visuals.forEach(v => v.updateColors());
                });

                window.addEventListener('resize', () => {
                    this.visuals.forEach(v => v.resize());
                });
            },

            setupObserver() {
                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const visual = this.visuals.find(v => v.canvas === entry.target);
                        if (visual) {
                            visual.isVisible = entry.isIntersecting;
                        }
                    });
                }, { threshold: 0.1 });
            },

            renderGrid(data) {
                const grid = document.getElementById('cardsGrid');
                grid.innerHTML = '';

                // Disconnect old observations
                this.visuals.forEach(v => this.observer.unobserve(v.canvas));
                this.visuals = [];

                if (data.length === 0) {
                    grid.innerHTML = '<div class="message-state">No topics found matching your criteria.</div>';
                    return;
                }

                data.forEach((item, index) => {
                    const card = document.createElement('article');
                    card.className = 'card';
                    card.style.opacity = 0;
                    card.onclick = () => this.handleCardClick(item);

                    card.innerHTML = `
                        <div class="card-visual">
                            <canvas id="canvas-${item.id}"></canvas>
                        </div>
                        <div class="card-content">
                            <div class="card-tag">${item.domain}</div>
                            <h3>${item.title}</h3>
                            <p>${item.desc}</p>
                            <div class="card-footer">
                                <span>Explore Module</span>
                                <i data-lucide="arrow-right" class="icon-arrow" width="16"></i>
                            </div>
                        </div>
                    `;
                    grid.appendChild(card);

                    // Initialize Visual
                    const canvas = card.querySelector('canvas');
                    setTimeout(() => {
                        let visual;
                        switch (item.type) {
                            case 'oscillation': visual = new OscillationVisual(canvas); break;
                            case 'projectile': visual = new ProjectileVisual(canvas); break;
                            case 'waves': visual = new WavesVisual(canvas); break;
                            case 'orbit': visual = new OrbitVisual(canvas); break;
                            case 'fields': visual = new FieldVisual(canvas); break;
                            case 'pendulum': visual = new PendulumVisual(canvas); break;
                            case 'slit': visual = new SlitVisual(canvas); break;
                            case 'magnetic': visual = new MagneticVisual(canvas); break;
                            default: visual = new BaseVisual(canvas);
                        }
                        visual.resize();
                        this.visuals.push(visual);
                        this.observer.observe(canvas); // OPTIMIZATION: Observe!
                    }, 50);
                });

                if (window.lucide) window.lucide.createIcons();

                gsap.to('.card', {
                    opacity: 1,
                    y: 0,
                    duration: 0.6,
                    stagger: 0.1,
                    ease: "power2.out"
                });
            },

            setupFilters() {
                const searchInput = document.getElementById('searchInput');
                const filterBtns = document.querySelectorAll('.filter-chip');
                let currentFilter = 'all';
                let currentSearch = '';

                const filterData = () => {
                    const filtered = DATA.filter(item => {
                        const matchesDomain = currentFilter === 'all' || item.domain === currentFilter;
                        const matchesSearch = item.title.toLowerCase().includes(currentSearch) ||
                            item.desc.toLowerCase().includes(currentSearch);
                        return matchesDomain && matchesSearch;
                    });
                    this.renderGrid(filtered);
                };

                searchInput.addEventListener('input', (e) => {
                    currentSearch = e.target.value.toLowerCase();
                    filterData();
                });

                filterBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        filterBtns.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentFilter = btn.dataset.filter;
                        filterData();
                    });
                });
            },

            animateLoop() {
                // Loop is always running, but individual draw() calls check isVisible flag
                this.visuals.forEach(v => v.draw());
                requestAnimationFrame(() => this.animateLoop());
            },

            handleCardClick(item) {
                if (item.href) {
                    window.location.href = item.href;
                } else {
                    alert(`Detailed view for ${item.title} is under construction.`);
                }
            }
        };

        window.addEventListener('DOMContentLoaded', () => {
            gsap.from('.library-header', { opacity: 0, y: -20, duration: 1, ease: 'power3.out' });
            App.init();
        });

    </script>
</body>

</html>